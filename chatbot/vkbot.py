# -*- coding: utf-8 -*-
from pprint import pprint
import random

from chatbot._token import token
import vk_api
import vk_api.bot_longpoll

# Вопрос - подскажите, пож, почему недостаточно просто импорта vk_api - в видеоуроке это не объясняется,
# кусок вырезан, import vk_api.bot_longpoll просто появляется в какой-то момент.
#  vk_api это по сути пакет, если пройдете по ссылке - попадете в __init__
#  И в нём прописаны автоматические импорты (минимум для работы с библиотекой)
#  Среди этого минимума нету нужного нам bot_longpoll
#  (возможно его исключили из автоматического импорта после урока)

# C этой конструкцией не разобрался, что она делает?
# class DotDict(dict):
#     __getattr__ = dict.get
#     __setattr__ = dict.__setitem__
#     __delattr__ = dict.__delitem__
#  Эта конструкция позволяет получать доступ к элементам словаря через точку
#  словарь = {'val': '123'}
#  словарь = DotDict(словарь)
#  словарь.val --> Это будет равно значению '123'
# TODO: для чего конструкция я понял, непонятно как это работает на уровне интерпретатора
# TODO: а можно чуть подробнее - класс DotDict наследуется от словаря, что происходит потом?
# TODO:__getattr__ по идее метод, его не переопределяют а присваивают ему я так думаю метод словаря,
# TODO: мы так не делали, поэтому такая конструкция у меня вызывает недоумение, я не понимаю как это работает.

# B и еще вопрос, не всегда через "." в списке появляются нужные атрибуты/классы с чем это может быть связано?
# Не понял вопрос, возможно он связан с тем, на что я ответил выше
# TODO: когда я набираю текст кода, иногда для удобства я через точку пытаюсь достучать до каких-то атрибутов
#  или методов, с этой библиотекой у меня многое не отображалось приходилось копировать, почему так происходит?


id_group = 190258846


class BotVk:

    def __init__(self, id_group, token):
        self.id_group = id_group
        self.token = token
        self.vk = vk_api.VkApi(token=token)
        self.long_poller = vk_api.bot_longpoll.VkBotLongPoll(self.vk, self.id_group)
        self.api = self.vk.get_api()

    def run(self):
        for event in self.long_poller.listen():
            print('получено событие')
            try:
                self.on_event(event)
            except Exception as exp:
                print(exp)

    def on_event(self, event):
        if event.type == vk_api.bot_longpoll.VkBotEventType.MESSAGE_NEW:


            # а как лектор понял, что можно так написать? Почему мы не создавали объект класса VkBotEventType?
            #  Что-то похожее мы делали с элементами в 7.02
            #  Про объект вопроса не понял, мы получаем на вход объект и пытаемся узнать его класс
            #  Это один из способов
            #TODO: я думал, что прежде чем обращаться к методам и атрибутам класса необходимо создать его
            # экземпляр, вот это выражение vk_api.bot_longpoll.VkBotEventType.MESSAGE_NEW сразу обращается
            # к классу который мы не создавали, либо я этот момент упустил.

            # Поясните пожалуйста что делают эти строчки кода?
            #  В одном из первых модулей мы создавали словарь с функциями, которые потом можно было вытащить
            #  по ключу и использовать (задание 4.03).
            #  Это примерно такая же структура, только с Классами, вернее с Классом
            #  Так, по ключу мы сможем создать объект нужного класса
            #  Вот там далее это используется
            # TODO хорошо давайте вернемся к уроку 4:
            #  {'name': 'Треугольник', 'func': triangle}
            #  func_of_dict = figures[user_figure]['func']
            #  func_of_dict(point=point, length=length, angle=0, color_figure=figures_color)
            #  triangle - какой это объект в первой строчке? это и не текст и не вызов функции, ссылка?
            #  вторая строчка как я понимаю, func_of_dict тоже ссылка на определение функции, наверное
            #  такие приемы просто зашиты в интерпретатор и мне надо запомнить? Так как логики я не вижу)
            #  Я понимаю определение функции и вызов функции, а такой подход не понимаю, помогите пожалуйста)
            # def _parse_event(self, raw_event):
            #     event_class = self.CLASS_BY_EVENT_TYPE.get(
            #         raw_event['type'],
            #         self.DEFAULT_EVENT_CLASS
            #     )  #  Тут получают класс из словаря
            #     return event_class(raw_event)
            #   Тут возвращают объект этого класса (добавлены скобки для создания объекта)

            # Классы для событий по типам
            #     CLASS_BY_EVENT_TYPE = {
            #         VkBotEventType.MESSAGE_NEW.value: VkBotMessageEvent,
            #         VkBotEventType.MESSAGE_REPLY.value: VkBotMessageEvent,
            #         VkBotEventType.MESSAGE_EDIT.value: VkBotMessageEvent,
            #     }
            #
            #     #: Класс для событий
            #     DEFAULT_EVENT_CLASS = VkBotEvent
            # Это нормально, что у меня столько вопросов на 4 месяце обучения?
            #  Это нормально. Хорошо, что вы изучаете библиотеки изнутри
            #  Однако обратите внимание, что все вопросы (кроме наверное DotDict) касаются кода
            #  В котором используются знакомые вам приемы, просто немного измененные/необычные
            #  Это наверное первая библиотека на курсе, которую необходимо изнутри изучить
            #  Она не простая, но важно помнить, что она состоит из простых частей
            #  Старайтесь находить все зависимости, переменные, чьи имена используются, думайте о типах
            #  используемых объектов
            # Хочется подробно обсудить эту библиотеку, последовательно, что - откуда, и почему.
            # TODO: Мне кажется будет очень полезно для студентов добавить урок в раздел интроспекции, где
            #  подробно разберут какую - нибудь библиотеку, построчно, досконально. Я не просто так сросил,
            #  нормально ли такое количество вопросов у меня, так как после этого раздела у меня сложилось ощущение,
            #  что я не совсем поспеваю за лектором, как-будто пропустил пару десятков лекций. Что называется
            #  "с места в карьер". Как мне быть?

            print(event.message.text)

            self.api.messages.send(message=event.message.text,
                                   random_id=random.randint(0, 2 ** 20),
                                   peer_id=event.message.peer_id
                                   )
        else:
            print("Мы пока не умеем обрабатывать события такого типа.", event.type)


if __name__ == "__main__":
    BotDrink = BotVk(id_group, token)
    BotDrink.run()

