# -*- coding: utf-8 -*-
from pprint import pprint
import random

from chatbot._token import token
import vk_api
import vk_api.bot_longpoll

# Вопрос - подскажите, пож, почему недостаточно просто импорта vk_api - в видеоуроке это не объясняется,
# кусок вырезан, import vk_api.bot_longpoll просто появляется в какой-то момент.
#  vk_api это по сути пакет, если пройдете по ссылке - попадете в __init__
#  И в нём прописаны автоматические импорты (минимум для работы с библиотекой)
#  Среди этого минимума нету нужного нам bot_longpoll
#  (возможно его исключили из автоматического импорта после урока)

# C этой конструкцией не разобрался, что она делает?
# class DotDict(dict):
#     __getattr__ = dict.get
#     __setattr__ = dict.__setitem__
#     __delattr__ = dict.__delitem__
#  Эта конструкция позволяет получать доступ к элементам словаря через точку
#  словарь = {'val': '123'}
#  словарь = DotDict(словарь)
#  словарь.val --> Это будет равно значению '123'
# для чего конструкция я понял, непонятно как это работает на уровне интерпретатора
# а можно чуть подробнее - класс DotDict наследуется от словаря, что происходит потом?
# __getattr__ по идее метод, его не переопределяют а присваивают ему я так думаю метод словаря,
#  мы так не делали, поэтому такая конструкция у меня вызывает недоумение, я не понимаю как это работает.
# TODO Что-то похожее мы обсуждали с вами только что) про переопределение requests.get
# TODO Мы заменяем методы словаря, __getattr__ позволяет нам получать атрибут, по его имени через точку
# TODO Заменив его мы при попытке получить атрибут запускаем метод get, где ключом будет имя, записанное через точку
# TODO Подробнее можно узнать почитав в документации словаря о методах, с которыми он работает
# B и еще вопрос, не всегда через "." в списке появляются нужные атрибуты/классы с чем это может быть связано?
# Не понял вопрос, возможно он связан с тем, на что я ответил выше
# когда я набираю текст кода, иногда для удобства я через точку пытаюсь достучать до каких-то атрибутов
#  или методов, с этой библиотекой у меня многое не отображалось приходилось копировать, почему так происходит?
# TODO А, это фича пайчарма, которая работает, когда может найти очевидные ссылки на объект
# TODO Если структура усложняется, то приходится всё искать вручную

id_group = 190258846


class BotVk:

    def __init__(self, id_group, token):
        self.id_group = id_group
        self.token = token
        self.vk = vk_api.VkApi(token=token)
        self.long_poller = vk_api.bot_longpoll.VkBotLongPoll(self.vk, self.id_group)
        self.api = self.vk.get_api()

    def run(self):
        for event in self.long_poller.listen():
            print('получено событие')
            try:
                self.on_event(event)
            except Exception as exp:
                print(exp)

    def on_event(self, event):
        if event.type == vk_api.bot_longpoll.VkBotEventType.MESSAGE_NEW:

            # а как лектор понял, что можно так написать? Почему мы не создавали объект класса VkBotEventType?
            #  Что-то похожее мы делали с элементами в 7.02
            #  Про объект вопроса не понял, мы получаем на вход объект и пытаемся узнать его класс
            #  Это один из способов
            #  я думал, что прежде чем обращаться к методам и атрибутам класса необходимо создать его
            # экземпляр, вот это выражение vk_api.bot_longpoll.VkBotEventType.MESSAGE_NEW сразу обращается
            # к классу который мы не создавали, либо я этот момент упустил.
            # TODO Класс создаётся вот этим методом из bot_longpoll
            """
            def _parse_event(self, raw_event):
                event_class = self.CLASS_BY_EVENT_TYPE.get(
                    raw_event['type'],
                    self.DEFAULT_EVENT_CLASS
                )
                return event_class(raw_event)
            """
            # Поясните пожалуйста что делают эти строчки кода?
            #  В одном из первых модулей мы создавали словарь с функциями, которые потом можно было вытащить
            #  по ключу и использовать (задание 4.03).
            #  Это примерно такая же структура, только с Классами, вернее с Классом
            #  Так, по ключу мы сможем создать объект нужного класса
            #  Вот там далее это используется
            # TODO хорошо давайте вернемся к уроку 4:
            #  {'name': 'Треугольник', 'func': triangle}
            #  func_of_dict = figures[user_figure]['func']
            #  func_of_dict(point=point, length=length, angle=0, color_figure=figures_color)
            #  triangle - какой это объект в первой строчке? это и не текст и не вызов функции, ссылка?
            # TODO Это вполне можно проверить при помощи type(triangle), в данном случае это функция
            # TODO Функция, как и Класс могут быть объектами (когда указаны без скобок)
            # TODO В таком виде их можно хранить, например, в словаре
            # TODO Далее мы берем объект из словаря figures[user_figure]['func']
            # TODO Читаем название словаря -- Идём в этот словарь -- По ключам приходим к функции
            # TODO В итоге привязываем к переменной ссылку на объект-функцию
            # TODO И далее с этой переменной можно обращаться как с функцией - добавить () для вызова тела функции
            # TODO func_of_dict(point=point, length=length, angle=0, color_figure=figures_color)
            # TODO срабатывает тело функции
            #  вторая строчка как я понимаю, func_of_dict тоже ссылка на определение функции, наверное
            #  такие приемы просто зашиты в интерпретатор и мне надо запомнить? Так как логики я не вижу)
            #  Я понимаю определение функции и вызов функции, а такой подход не понимаю, помогите пожалуйста)
            # def _parse_event(self, raw_event):
            #     event_class = self.CLASS_BY_EVENT_TYPE.get(
            #         raw_event['type'],
            #         self.DEFAULT_EVENT_CLASS
            #     )  #  Тут получают класс из словаря
            #     return event_class(raw_event)
            # TODO Здесь мы получаем объект-класс из словаря self.CLASS_BY_EVENT_TYPE
            # TODO Привязываем его к переменной event_class и далее создаем объект привязанного класса
            # TODO event_class(параметр) -- создание объекта
            # TODO пайтон идёт по ссылки и читает это как VkBotMessageEvent(параметр)
            #   Тут возвращают объект этого класса (добавлены скобки для создания объекта)

            # Классы для событий по типам
            #     CLASS_BY_EVENT_TYPE = {
            #         VkBotEventType.MESSAGE_NEW.value: VkBotMessageEvent,
            #         VkBotEventType.MESSAGE_REPLY.value: VkBotMessageEvent,
            #         VkBotEventType.MESSAGE_EDIT.value: VkBotMessageEvent,
            #     }
            #
            #     #: Класс для событий
            #     DEFAULT_EVENT_CLASS = VkBotEvent
            # Это нормально, что у меня столько вопросов на 4 месяце обучения?
            #  Это нормально. Хорошо, что вы изучаете библиотеки изнутри
            #  Однако обратите внимание, что все вопросы (кроме наверное DotDict) касаются кода
            #  В котором используются знакомые вам приемы, просто немного измененные/необычные
            #  Это наверное первая библиотека на курсе, которую необходимо изнутри изучить
            #  Она не простая, но важно помнить, что она состоит из простых частей
            #  Старайтесь находить все зависимости, переменные, чьи имена используются, думайте о типах
            #  используемых объектов
            # Хочется подробно обсудить эту библиотеку, последовательно, что - откуда, и почему.
            # Мне кажется будет очень полезно для студентов добавить урок в раздел интроспекции, где
            #  подробно разберут какую - нибудь библиотеку, построчно, досконально. Я не просто так сросил,
            #  нормально ли такое количество вопросов у меня, так как после этого раздела у меня сложилось ощущение,
            #  что я не совсем поспеваю за лектором, как-будто пропустил пару десятков лекций. Что называется
            #  "с места в карьер". Как мне быть?
            # TODO Предложение такое можете направить на hello@skillbox.ru
            # TODO Но не уверен, насколько будет это эффективно.
            # TODO На данном этапе от вас не требует досконального понимания библиотеки (без серьезных затрат по времени
            # TODO я сам не скажу, что досканально разбираюсь в ней, она довольно обширна)
            # TODO Могу посоветовать читать больше документации и сидеть часами, выслеживая взаимодействия объектов
            # TODO до самых простых сущностей (все сложные объекты рано или поздно распадаются на мелкие
            # TODO А мелкие либо вам известны, либо можно почитать о них в документации)
            # TODO Скорость осваивания таких библиотек растёт со временем.
            # TODO Работа с документацией - это уже опыт, который вам надо набирать самостоятельно

            print(event.message.text)

            self.api.messages.send(message=event.message.text,
                                   random_id=random.randint(0, 2 ** 20),
                                   peer_id=event.message.peer_id
                                   )
        else:
            print("Мы пока не умеем обрабатывать события такого типа.", event.type)


if __name__ == "__main__":
    BotDrink = BotVk(id_group, token)
    BotDrink.run()
