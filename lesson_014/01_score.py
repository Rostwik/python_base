# -*- coding: utf-8 -*-

# Вас взяли на работу в молодой стартап. Идея стартапа - предоставлять сервис расчета результатов игр.
# Начать решили с боулинга, упрощенной версии.
#
# Правила такие.
#
# Всего 10 кеглей. Игра состоит из 10 фреймов. В одном фрейме до 2х бросков, цель - сбить все кегли.
# Результаты фрейма записываются символами:
#   «Х» – «strike», все 10 кеглей сбиты первым броском
#   «<число>/», например «4/» - «spare», в первый бросок сбиты 4 кегли, во второй – остальные
#   «<число><число>», например, «34» – в первый бросок сбито 3, во второй – 4 кегли.
#   вместо <число> может стоять прочерк «-», например, «-4» - ни одной кегли не было сбито за бросок (первый или второй)
# Результат игры – строка с записью результатов фреймов. Символов-разделителей между фреймами нет.
# Например, для игры из 3 фреймов запись результатов может выглядеть так:
#   «Х4/34»
# Предлагается упрощенный способ подсчета количества очков:
#   «Х» – 20 очков, «4/» - 15 очков, «34» – сумма 3+4=7
# То есть для игры «Х4/34» сумма очков равна 20+15+7=42
#
# Надо написать python-модуль (назвать bowling), предоставляющий API расчета количества очков:
# функцию get_score, принимающую параметр game_result. Функция должна выбрасывать исключения,
# когда game_result содержит некорректные данные. Использовать стандартные исключения по максимуму,
# если не хватает - создать свои.
#
# Обязательно написать тесты на этот модуль. Расположить в папке tests.

# Из текущего файла сделать консольную утилиту для определения количества очков, с помощью пакета argparse
# Скрипт должен принимать параметр --result и печатать на консоль:
#   Количество очков для результатов ХХХ - УУУ.

from lesson_014.bowling import get_score

get_score('2/37X11111111--2821')


# При написании кода помнить, что заказчик может захотеть доработок и новых возможностей...
# И, возможно, вам пригодится паттерн проектирования "Состояние",
#   см https://clck.ru/Fudd8 и https://refactoring.guru/ru/design-patterns/state

#  Подскажите, пожалуйста, патерн "Состояние"
#  Вы предлагаете применить к модулю подсчета очков или к модулю консольной части.
#  Я почитал ссылки, что указаны в описании, смысл понял, но не вижу как это применить к данной задаче.
#  Его применить можно к модулю подсчёта очков - для реализации первого и второго броска отдельно
#  Создаётся класс бросок - добавляются тонкости расчётов (как считывается символ 'X', как '/')
#  Затем в наследниках описываются первый бросок и второй (у первого не может быть spare '/',
#  У второго не может быть strike 'X')
#  И в итоге от броска (состояния - первый/второй) зависит трактовка символов

#  Вопрос по лекции - так как лекцию я не понял, нужна помощь:
#  test_handling_external_data.py
#     def test_normal(self):
#         getter = ExternalResourceGetter(url='bla-bla-bla')
#          Тут мы создаем объект класса, описанного в handling_external_data.py
#          Сам класс реализует обработку данных полученных запросом с какого-нибудь сайта по заданному URL
#          Запрос производится при помощи библиотеки requests и метода .get
#         fake_result = Mock()   Тут мы создаём пустышку (подробнее тут https://habr.com/ru/post/141209/)
#         fake_result.text = _test_data
#         fake_get_result = Mock(return_value=fake_result)   А здесь говорим этой пустышке возвращать данные
#          При обращении к ней. Так, обращение к fake_get_result вернёт нам fake_result
#          А точнее атрибут .text, который содержит строки заданные выше в _test_data
#         handling_external_data.requests.get = fake_get_result
#          Здесь мы подменяем импортированный метод get, который должен обращаться к сайту и получать данные с него
#          Другим элементом-пустышкой, который всегда будет возращать заданные выше строки
#         result = getter.run()
#          Теперь мы можем протестировать наш класс, запустив его главный метод run
#          Который в процессе будет получать данные при помощи requests.get, но тк мы подменили этот метод
#          То данные придут не с сайта, а тестовые, которые мы создали сами
#         self.assertEqual(result, 9)
#          А тут мы сравниваем результат обработки наших данных с тем, что должно получиться
#  Для понимания важно понять последовательность шагов
#  import в самом начале выполняет код из библиотеки requests
#  значит где-то в нашем поле имен создается метод get который обращается к внешнему ресурсу
#  Затем создаётся класс, который использует этот метод
#  Затем в тестовом модуле переменная get переопределяется
#  И далее, при обращении к ней будет уже не оригинальный метод выполняться, а тот, который мы указали
# тут вопрос: можете по шагам объяснить  что делает каждая строчка,
# особенно вот эта handling_external_data.requests.get = fake_get_result
# преподаватель объяснил, что таким образом мы переопределяем функцию
# requests.get мы так раньше не делали, хочу понять механику,
# как это работает на уровне интерпретатора. Спасибо.

